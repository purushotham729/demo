package com.example.ai.multiagent;

import com.alibaba.cloud.ai.graph.StateGraph;
import com.alibaba.cloud.ai.graph.OverAllState;
import com.alibaba.cloud.ai.graph.CompiledGraph;
import com.alibaba.cloud.ai.graph.action.NodeAction;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

// Tools for Orchestrator and BA Agent
class AgentTools {
    private final ChatClient client;

    public AgentTools(ChatClient client) {
        this.client = client;
    }

    // Decide which agent to invoke
    public String decideAgent(String query) {
        String prompt = "Classify query: '" + query + "'. Return 'BA' for BRD analysis, 'Dev' for coding tasks. Only return the agent name.";
        return client != null ? client.call(prompt).trim() : (query.toLowerCase().contains("analyze") ? "BA" : "Dev");
    }

    // Analyze BRD content and return JSON
    public String analyzeBRD(String brdContent) {
        String prompt = "Convert BRD to JSON: { \"requirements\": [], \"summary\": \"\" }. Content: " + brdContent;
        return client != null ? client.call(prompt) : "{\"requirements\": [\"Feature 1\", \"Feature 2\"], \"summary\": \"BRD summary\"}";
    }

    // Generate code
    public String generateCode(String requirement) {
        return "public class Application { public void run() { System.out.println(\"Implementing: " + requirement + "\"); } }";
    }
}

// ReactAgent for Dev and BA
class ReactAgent {
    public final String name;
    private final ChatClient client;
    private final List<String> tools;
    private final int maxIterations;

    public ReactAgent(String name, ChatClient client, List<String> tools, int maxIterations) {
        this.name = name;
        this.client = client;
        this.tools = tools;
        this.maxIterations = maxIterations;
    }

    public String execute(String task, Map<String, Object> context) {
        String response = "";
        for (int i = 0; i < maxIterations; i++) {
            String prompt = "Task: " + task + ". Context: " + context + ". Use tools if needed.";
            response = client != null ? client.call(prompt) : "Processing " + task;
            if (name.equals("BA") && tools.contains("analyze_brd") && task.toLowerCase().contains("analyze")) {
                String brdContent = (String) context.getOrDefault("brd_content", "");
                response = new AgentTools(client).analyzeBRD(brdContent);
                break;
            } else if (name.equals("Dev") && tools.contains("code_gen") && task.toLowerCase().contains("develop")) {
                String requirement = (String) context.getOrDefault("brd_content", "");
                response = new AgentTools(client).generateCode(requirement);
                break;
            }
            if (response.contains("done")) break;
        }
        return response;
    }
}

// OrchestratorAgent using StateGraph
class OrchestratorAgent {
    private final AgentTools tools;
    private CompiledGraph compiledGraph;
    private List<ReactAgent> workerAgents;

    public OrchestratorAgent(AgentTools tools) {
        this.tools = tools;
        buildAndCompileGraph();
    }

    private void buildAndCompileGraph() {
        StateGraph stateGraph = new StateGraph()
            .addNode("plan", new PlanNode())
            .addNode("delegate", new DelegateNode())
            .addNode("synthesize", new SynthesizeNode())
            .addEdge(StateGraph.START, "plan")
            .addEdge("plan", "delegate")
            .addEdge("delegate", "synthesize")
            .addEdge("synthesize", StateGraph.END);

        this.compiledGraph = stateGraph.compile();
    }

    private class PlanNode implements NodeAction {
        @Override
        public Map<String, Object> apply(OverAllState state) {
            String query = state.value("query", "");
            String chosenAgent = tools.decideAgent(query);
            return Map.of("chosen_agent", chosenAgent);
        }
    }

    private class DelegateNode implements NodeAction {
        @Override
        public Map<String, Object> apply(OverAllState state) {
            String chosenAgentName = state.value("chosen_agent", "");
            String query = state.value("query", "");
            String brdContent = state.value("brd_content", "");

            ReactAgent chosenAgent = workerAgents.stream()
                .filter(agent -> agent.name.equals(chosenAgentName))
                .findFirst()
                .orElse(null);

            if (chosenAgent != null) {
                Map<String, Object> context = new HashMap<>();
                context.put("brd_content", brdContent);
                String result = chosenAgent.execute(query, context);
                return Map.of("result", result);
            }
            return Map.of("result", "No agent found");
        }
    }

    private class SynthesizeNode implements NodeAction {
        @Override
        public Map<String, Object> apply(OverAllState state) {
            return state.value();
        }
    }

    public String execute(String userQuery, String brdContent, List<ReactAgent> agents) {
        this.workerAgents = agents;
        Map<String, Object> initialState = new HashMap<>();
        initialState.put("query", userQuery);
        initialState.put("brd_content", brdContent);

        OverAllState finalState = compiledGraph.invoke(initialState)
            .orElseThrow(() -> new RuntimeException("Graph execution failed"));
        return (String) finalState.value("result").orElse("No result");
    }
}

// REST Controller for API endpoint
@RestController
class MultiAgentController {
    private final OrchestratorAgent orchestrator;
    private final ChatClient chatClient;

    @Autowired
    public MultiAgentController(ChatClient chatClient) {
        this.chatClient = chatClient;
        AgentTools tools = new AgentTools(chatClient);
        ReactAgent devAgent = new ReactAgent("Dev", chatClient, List.of("code_gen"), 5);
        ReactAgent baAgent = new ReactAgent("BA", chatClient, List.of("analyze_brd"), 5);
        this.orchestrator = new OrchestratorAgent(tools);
        this.orchestrator.workerAgents = List.of(devAgent, baAgent);
    }

    @PostMapping("/process")
    public ResponseEntity<Map<String, String>> processRequest(@RequestBody RequestPayload payload) {
        String query = payload.getQuery();
        String brdContent = payload.getBrdContent();
        String result = orchestrator.execute(query, brdContent, orchestrator.workerAgents);
        return ResponseEntity.ok(Map.of("result", result));
    }
}

// Request payload class
class RequestPayload {
    private String query;
    private String brdContent;

    public String getQuery() {
        return query;
    }

    public void setQuery(String query) {
        this.query = query;
    }

    public String getBrdContent() {
        return brdContent;
    }

    public void setBrdContent(String brdContent) {
        this.brdContent = brdContent;
    }
}
